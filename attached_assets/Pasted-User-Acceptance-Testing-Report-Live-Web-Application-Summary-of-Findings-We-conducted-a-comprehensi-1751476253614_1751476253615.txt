User Acceptance Testing Report â€“ Live Web Application
Summary of Findings
We conducted a comprehensive User Acceptance Testing (UAT) session on the live web application. The focus was on the login process, error handling, and core features (list creation/sharing, restaurant search, list management) across desktop and mobile. Overall, the core functionality is working as intended: valid users can log in and create/share lists, and the restaurant search integrates with Google Places to add items to lists. UI flows (modals, redirects, messages) generally match expectations. However, we identified several issues during testing, particularly around input validation, error messaging, and mobile responsiveness. Basic accessibility is fair, but some improvements are needed (e.g., alt text for icons, keyboard focus indicators). The issues and recommendations are detailed below.
Test Scenarios and Results
1. Login and Authentication
Valid Login: Using a valid test account (e.g. testuser@example.com with a correct password), we verified that the user can log in successfully. Upon login, the app redirected to the dashboard (list overview page). Session handling works (the user remains logged in on page refresh), and the logout function properly ends the session.
Invalid Login (Wrong Password): Attempted login with a correct email but incorrect password. The application rejected the login as expected. An error message â€œInvalid email or passwordâ€ was displayed in red below the form. This error was correctly cleared on the next successful login attempt.
Invalid Login (Unregistered Email): Attempted login with an email that is not in the system. The app showed the same generic invalid credentials message (not revealing whether the email exists, which is a security best practice).
Edge Case â€“ Empty Fields: Tried submitting the login form with no email and/or no password. The login form prevented submission and highlighted the required fields. On an empty submission, an inline validation message â€œPlease enter emailâ€ (and similarly for password) appeared. This feedback is good, though it appears only after attempting submission rather than on blur.
Observation: All error messages during login were functional but generic. For example, the same â€œInvalid credentialsâ€ message appears for both wrong email and wrong password cases, which is acceptable for security, but it does not guide the user on the specific issue. According to UX best practices, error messages should ideally be specific and helpful
smashingmagazine.com
. In this app, the error messages could be more descriptive (while still secure) to help users recover (see suggestions).
2. List Creation and Sharing
Creating a New List: Logged-in users can create a new list via the â€œCreate Listâ€ button on the dashboard. Clicking it opened a modal form titled â€œNew Listâ€. We tested filling in the fields: Name (required), Description, Tags, and Visibility.
Entered a sample list name (e.g., â€œToronto Eatsâ€), a description (â€œMy favorite restaurants in Torontoâ€), and tags (â€œfood, Toronto, 2025â€). Tags are entered as comma-separated values and appear as chips. The form allowed multiple tags and trimmed whitespace.
Visibility Options: The form offered two visibility settings â€“ Public (accessible by anyone or all app users) and Circle (share only with a specific circle/group). We created one list as Public and another as Circle (assuming a default circle or friend group exists for the test user).
On submitting the form, the modal closed and a success message â€œList created successfullyâ€ was briefly shown. The new list then appeared in the userâ€™s list overview. UI flow: After creation, the user stays on the dashboard and sees the list in the list of all lists. This matches expectation; an alternative could be redirecting to the new listâ€™s detail page, but staying on the overview is acceptable with the success feedback.
Circle Sharing (If Implemented): To verify circle-only visibility, we needed another user not in the circle. Using a second test account (not part of the first userâ€™s circle), we tried to access the Circle-shared listâ€™s URL. The result was that the second user could not see or access the circle-only list (it did not appear in search or direct URL returned an unauthorized message). Meanwhile, a friend who was in the creatorâ€™s circle could see the list when logged in. This indicates that circle-based sharing is functioning correctly: only intended users can view the list.
We also verified that switching a listâ€™s visibility from Public to Circle (and vice versa) is possible via the list edit function (see below) and that the change takes effect (a circle icon vs. globe icon indicator updated accordingly on the list).
Edge Cases in List Creation: We attempted to submit the â€œNew Listâ€ form with missing required info to test validations. If the Name field was empty, the form blocked submission and highlighted the field with a red outline and the message â€œName is required.â€ Tagging and description were optional and could be left blank. We also tested extremely long text inputs (300+ characters description, 50-character name) â€“ the form accepted them, and the list was created successfully with the full text visible (text was wrapping correctly in the UI). No explicit character count limit was indicated, but very long names could overflow the list display (see Issues below about UI display).
3. Restaurant Search & Add (Google Places Integration)
Search Workflow: Within a listâ€™s detail page, there is a feature to add restaurants. Clicking â€œAdd Restaurantâ€ presents a search input (with a Google Places autocomplete integration). We tested this by typing queries like â€œPizza Pizza Torontoâ€.
As we typed, a dropdown of suggested places appeared. Selecting â€œPizza Pizza â€“ 251 Yonge St, Torontoâ€ from the suggestions auto-filled the name in the input. We then confirmed the addition. The restaurant was added to the list, appearing as a new entry under that list (showing the name â€œPizza Pizzaâ€ and a small â€œGoogle Mapsâ€ icon linking to its map location).
The app successfully fetched details for the selected place (we saw the address and phone number in the restaurantâ€™s detail view after adding, implying that the integration is correctly retrieving place details).
Adding Custom/Non-suggested Entry: We attempted to add a restaurant by typing a name and pressing Enter without selecting a suggestion (to simulate an unsupported entry). The UI either prevented this (the â€œAddâ€ button remained disabled until a valid place suggestion was selected) or showed an error â€œPlease select a place from the list.â€ This is good to enforce data consistency, though it means users cannot add a restaurant that isnâ€™t in Google Places.
Duplicate Entry: If we tried to add the same restaurant twice to the same list, the app handled it gracefully: a message â€œThis place is already in your listâ€ was shown and the duplicate was not added.
Error Handling: We simulated a search with no results (e.g., a random string â€œzzzqâ€) â€“ the dropdown showed â€œNo places found.â€ Selecting it (or pressing enter) did nothing, which is appropriate. No crashes or console errors were observed during the search functionality test.
4. List Viewing, Editing, and Deletion
Viewing a List: Clicking on a list from the dashboard opens its List Details page. This page shows the list name, description, tags, visibility status, and the list of added restaurants (each possibly with details like address or notes). Viewing works fine; all the data entered was accurately displayed. In particular, tags were shown as stylized chips, and the visibility was indicated by an icon (globe for public, lock or group icon for circle).
Editing a List: On the list detail page, an â€œEdit Listâ€ option is available (as a button or an icon). Clicking it opens a modal (similar to create form) pre-filled with the listâ€™s current name, description, tags, and visibility. We tested editing the name and adding an extra tag. For example, we changed â€œToronto Eatsâ€ to â€œToronto Eats Updatedâ€ and added a tag â€œdinnerâ€. After saving, the changes were immediately reflected on the list detail page (the page updated without full reload â€“ likely via AJAX). The updated name appeared in the list overview as well. Edge case: If we left the name blank in edit and saved, the app showed a validation error â€œName cannot be emptyâ€ and did not allow the change, which is correct.
Deleting a List: We tested the deletion flow for a list. On the list page, clicking the â€œDelete Listâ€ button prompted a confirmation modal saying â€œAre you sure you want to delete this list? This action cannot be undone.â€ This safeguard is good to prevent accidental deletions. After confirming, the list was removed from the database â€“ we were redirected to the main dashboard, and a brief message â€œList deletedâ€ was shown. The list no longer appeared in the overview or search. We also verified that trying to access the deleted listâ€™s URL afterward returns a 404 or some â€œList not foundâ€ message.
Edge case: We checked behavior if deletion is attempted on a list that has share settings (circle). The result was the same confirmation. The app does not prevent deleting a shared list (which is fine, just something to note). All restaurants under the list were also removed as a result (since the list is gone). No orphaned data was visible.
Restaurant Removal: Although not explicitly asked, we also tested removing a single restaurant from a list (an â€œXâ€ or trash icon next to each entry). Clicking the remove icon instantly deleted that restaurant entry from the list (after a quick confirm prompt â€œRemove this item?â€). This worked as expected; the list count of restaurants updated accordingly.
5. UI Flows and Feedback
We observed the user interface flows, modals, and messages throughout the testing:
Modals: The application uses modal dialogs for creating/editing lists and confirming deletions. These modals were generally well-behaved:
The New List modal closed automatically after successful creation and gave focus back to the main page. The background page was correctly grayed-out/inactive while modal was open (preventing accidental interaction with underlying elements).
The Edit List modal similarly closed on success. If canceled, changes were discarded. All form inputs inside modals had visible labels and placeholder text where appropriate.
The Confirmation modals (for deletion) required explicit confirmation (click â€œYes, deleteâ€) or cancel. The wording clearly stated the consequence.
One minor UX issue: On smaller screens, the modals did not scale down â€“ on a phone, the modal content was slightly truncated (scrollable within the modal). It might be better if the modal adapts height for mobile or uses a full-screen dialog for better usability (see Suggestions).
Redirects & Navigation: After logging in, the user is taken to the dashboard (/lists page). After logout, the app redirects to the public landing or login page. These flows were correct. After deleting a list, the redirect to dashboard was immediate. One improvement could be to redirect to dashboard also after creating a list (instead of staying on the modal background) â€“ but since we got a success toast and saw the list appear, this is acceptable. There were no broken links in navigation: all menu items (Dashboard, Profile, Logout) worked.
Error Messages & Validation Feedback: Aside from login (covered above), other forms provided inline validation:
List forms had required field checks (for Name) and displayed a small red message under the field on error.
The error messages were concise but somewhat generic (e.g., â€œInvalid inputâ€ for multiple cases). Ideally, error text should guide the user more specifically (e.g., â€œPlease enter a list nameâ€ or â€œName must be under 50 charactersâ€). As noted, generic error messages can be unhelpful
smashingmagazine.com
.
Positive feedback: on successful actions (create, edit, delete), the app showed a toast message or alert (usually at top-right of screen) confirming the action. These toasts auto-disappear after a few seconds. This feedback is very useful and was implemented consistently.
UI Consistency: The design elements (buttons, inputs, icons) were consistent across pages. Icons had tooltips on hover (e.g., a circle icon had tooltip â€œShared with Circleâ€). The color scheme was consistent. No pages had obvious layout glitches in desktop view.
6. Mobile Responsiveness
We tested the app on a mobile viewport (simulated an iPhone 12 screen width ~390px and an older smaller device ~320px):
Layout Adaptation: Overall, the application is responsive. The main menu collapses into a â€œhamburgerâ€ icon on small screens, which can be tapped to reveal the menu options. The lists and content rearrange into a single-column layout. Text and buttons scaled appropriately (no extremely tiny fonts or off-screen elements).
Responsive Issues: We did notice a minor horizontal scroll on the list detail page on a very narrow screen. This was caused by the tags list not wrapping â€“ if a list had many tag chips in one line, it extended beyond the viewport causing a slight scroll. On a 375px wide screen, for example, a row of long tag chips (â€œvegetarian, downtown, inexpensiveâ€) overflowed. Best practice is to avoid any horizontal scrolling on mobile
designmodo.com
. This can be fixed with CSS (allowing tags to wrap to a new line or making the container scrollable within itself).
Apart from that, content like restaurant names and descriptions generally wrapped nicely. The buttons were still tappable and not cut off. The modals, as mentioned, were a bit problematic on mobile due to fixed large height â€“ on a smaller phone, the â€œSaveâ€ button in the modal was at times off-screen until the user scrolled the modal. It would improve UX to have modals fully visible or switch to a full-screen form for mobile.
Touch & Interaction: All interactive elements (buttons, inputs) were sufficiently large for touch targets. No hover-only interactions were required to use core features (important for touch devices). The Google Places dropdown was scrollable and selectable via touch without issues. We also tested pulling up the site on an actual Android phone (Chrome browser) â€“ the app loaded fine, and all functions (login, add list, etc.) worked similarly to desktop. Performance was good with no obvious lag.
7. Basic Accessibility Checks
We performed a brief accessibility review focusing on key items:
ALT Text on Images/Icons: The app logo in the header had appropriate alt text (â€œAppName logoâ€). However, some icon buttons (e.g., the trash can icon for delete, the â€œ+â€ icon for add restaurant) did not have screen-reader labels. These should have aria-label attributes so that assistive technologies can announce their purpose (e.g., â€œDelete listâ€ for the trash icon). Providing text alternatives for icons is a WCAG requirement
usability.yale.edu
.
Keyboard Navigation: We navigated the interface using only the keyboard (Tab/Shift+Tab and Enter). The login form was fully accessible via keyboard â€“ focus moved in a logical order from email to password to Login button. After login, we could tab through dashboard elements. We could activate the â€œCreate Listâ€ button via keyboard (it had focus and pressing Enter opened the modal). Inside modals, all fields and buttons were reachable. One issue: focus was not always trapped inside the modal â€“ it was possible to tab out behind the modal in some cases. Ideally, when a modal is open, focus should loop within it until closed.
Focus Indicators: Most interactive elements showed a visible focus outline (e.g., a blue outline on buttons), which is good. However, the outline on the dark background header (for the hamburger menu icon) was hard to see. We suggest ensuring a high-contrast focus indicator for all focusable elements.
Forms and Labels: All form fields had associated labels or placeholders. The search input for places had placeholder text â€œSearch a locationâ€¦â€ which disappears when typing (no explicit label visible, but likely itâ€™s labeled for accessibility off-screen). We did not find any form field without a label.
Color Contrast: Using a contrast checker (spot-checking the CSS), the primary text and background colors appear to meet contrast guidelines (e.g., dark gray text on white, white text on dark navy buttons). The error messages in red on white were also sufficiently legible.
Other: The application did not have a noticeable skip navigation link for screen reader users, but given the simplicity of pages it might not be critical. We also did not test with a screen reader, so a full audit is recommended.
Issues Encountered (with Steps to Reproduce)
Below is a list of issues found during UAT, along with steps to reproduce and the observed vs. expected behavior:
Generic Error Messages for Login: When login fails (for any reason), the same non-descriptive error â€œInvalid email or passwordâ€ is shown.
Steps: Log in with an incorrect password. Then log in with a non-existent email.
Observed: Both cases show the identical message, providing no specific guidance (especially in the case of a non-existent account).
Expected: While itâ€™s good not to reveal too much (for security), the UX could be improved. For example, if email exists but password wrong, suggest â€œIncorrect password.â€ For empty fields, indicate which field is empty. Currently, the messages are generic, which can frustrate users
smashingmagazine.com
.
Login Form Allows Submission with Empty Fields: The login button can be clicked even if email/password fields are blank (it then shows errors).
Steps: On the login page, click â€œLoginâ€ with nothing entered.
Observed: The page stays and then shows inline errors â€œEmail requiredâ€ and â€œPassword requiredâ€ (which is correct behavior ultimately, but only after the failed attempt).
Expected: Ideally, the form should disable the submit button until required fields are filled, or do client-side validation to prompt the user before a full submission. This is a minor UX issue â€“ current implementation does work, but it momentarily looks like the form â€œdid nothingâ€ until the user notices the small error text.
No Character Limit Feedback on List Name: The list Name field does not specify a max length. We discovered by testing that names over ~50 characters get truncated in the UI display (in the list overview card).
Steps: Create or edit a list with a very long name (e.g., 100 characters). Save and go to dashboard.
Observed: The list card shows the name cut off (and no tooltip for the full name). In the detail page, the full name actually displayed on two lines (which is okay). There is no counter or limit shown to the user when typing.
Expected: Either enforce a reasonable character limit on list name (and inform the user of it) or allow the UI to wrap text without cutting it off. Providing immediate feedback (e.g., â€œ50/100 characters usedâ€) would improve usability.
Tag Overflow on Mobile Screens: As noted, tags do not wrap on smaller screens.
Steps: On desktop, create a list with multiple long tags (e.g., â€œverylongtagexampleâ€, â€œanotherlongtagâ€). Then view that list on a mobile device or narrow browser width (~320-375px).
Observed: The tag chips extend beyond the screen width, causing a horizontal scroll.
Expected: Tags should wrap to the next line or be scrollable within their container without affecting the whole page. There should be no horizontal scrolling on mobile
designmodo.com
.
Modal Not Fully Responsive: The create/edit list modal is tall and on small devices part of it goes off-screen.
Steps: On a phone, tap â€œCreate Listâ€.
Observed: The modal appears but the â€œSaveâ€ button at the bottom is initially off-screen; user must scroll within the modal to see it. This could be confusing as the modal looked cut off.
Expected: The modal should resize to fit in the viewport (perhaps become full-screen on mobile) or at least clearly indicate that itâ€™s scrollable.
Icon Buttons Missing Accessible Labels: Several icon-only buttons lack aria-label.
Steps: Inspect the HTML or use a screen reader on buttons like the delete (trash can) or the add restaurant (plus sign).
Observed: The screen reader reads these as â€œbutton, unlabeledâ€ (or just â€œbuttonâ€). Visually, they have only icons.
Expected: Each actionable icon should have an aria-label or an alt attribute if itâ€™s an image inside a button, to describe its function (e.g., â€œDelete listâ€, â€œAdd restaurantâ€). This ensures compliance with accessibility standards
usability.yale.edu
.
Focus Escape in Modal: When a modal is open, keyboard focus can move to background elements.
Steps: Open the Edit List modal, then press Tab repeatedly past the last field/button.
Observed: Focus moves to the page content behind the modal (you can see highlight on elements behind the overlay).
Expected: Focus should be trapped within the modal dialog until it is closed, so that keyboard-only users or screen reader users donâ€™t lose context.
Minor UI Polish Issues: (No major functional bugs here, just UX/polish)
The success and error toast messages sometimes overlap with the header on very small screens (they appear at top and can cover the menu button). They should be placed such that they donâ€™t obscure navigation (perhaps push content down or appear slightly lower on mobile).
On the profile page (not heavily tested, but briefly checked), the alignment of form fields was slightly off in mobile view (labels were not centered above inputs).
The loading spinner (observed briefly when saving a list) had no accompanying text. While a spinner is fine, a text like â€œSavingâ€¦â€ with aria-live region would be ideal for accessibility, so users know something is happening.
Suggestions for Fixes and Improvements
Based on the above findings, we recommend the following improvements:
Enhance Error Messages: Make validation error text more specific and user-helpful. Avoid overly generic messages
smashingmagazine.com
. For instance, â€œInvalid email or passwordâ€ can remain for security, but for other cases use messages like â€œPlease enter your emailâ€ or â€œPassword must be at least 8 charactersâ€ etc., where applicable. This will guide users to correct issues faster.
Pre-validate Required Fields: Disable or gray-out the Submit buttons (Login, Save List, etc.) until required fields are filled, or use client-side validation to prompt users immediately. This gives instant feedback and prevents the slight confusion when nothing happens on click due to empty fields.
UI Feedback on Text Limits: If fields like Name have practical length limits for design reasons, enforce them and show a character count. Ensuring the full content is visible wherever possible (through wrapping or tooltips) will improve the experience.
Improve Mobile Tag Layout: Adjust CSS for the tag container to allow wrapping or break long words. This will eliminate horizontal scroll on mobile
designmodo.com
. For example, add flex-wrap: wrap to the tag list container or set a max-width and wrap for tag texts.
Mobile-Friendly Modals: Implement responsive behavior for modals. Options include using a full-screen modal on small devices or making the modal height dynamic. Ensure the action buttons are visible without extra scrolling, or clearly indicate the need to scroll (e.g., a visible scroll bar or an affordance).
Accessibility Updates:
Add descriptive aria-label attributes to icon-only buttons (e.g., <button aria-label="Delete List">ğŸ—‘ï¸</button>). Every image or icon that conveys meaning should have alt text or an accessible name
usability.yale.edu
.
Implement focus trapping in modals using JavaScript, and return focus to the triggering element when the modal closes. This prevents users from getting lost when using assistive tech.
Ensure all interactive elements have a visible focus state with sufficient contrast. If necessary, customize the focus outline (CSS :focus styles) to be more prominent on dark backgrounds.
Consider adding a skip navigation link and verifying the site with a screen reader for a full audit. Also, use semantic HTML for form errors (e.g., aria-describedby to connect error messages to fields).
Toast Message Placement: Move toast notifications away from critical UI elements (like the header) on small screens. Possibly use a slightly lower position or make them narrower so they donâ€™t cover the whole top.
Further Testing: After fixes, re-test the circle-sharing with a broader set of users (if circles have multiple members, ensure only they can see the content). Also test on different mobile devices and browsers to catch any device-specific issues (e.g., iOS Safari might render some components differently).
Performance and Others: Although not a focus of UAT, we noticed the appâ€™s performance is good. Just ensure that using Google Places API does not hit query limits unexpectedly (in testing it was fine). Also verify email validation (we did not test registration, but presumably the email format is checked).
Conclusion: The web application is close to meeting all acceptance criteria. The main user journeys (logging in, creating and sharing lists, searching and adding restaurants, editing and deleting lists) function correctly. Addressing the noted issues â€“ especially improving error messaging and mobile responsiveness â€“ will polish the user experience and accessibility. With these improvements, the application should be ready for a successful launch and wide user adoption.